# Task 5.4.4: Automated deployment with Docker Compose
# Blue-green deployment strategy with rollback mechanisms and health checks
# Environment-specific deployments with comprehensive validation

name: Automated Deployment

on:
  workflow_run:
    workflows: ["Docker CI/CD Pipeline"]
    types: [completed]
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - development
          - staging
          - production
      deployment_strategy:
        description: 'Deployment strategy'
        required: false
        default: 'rolling'
        type: choice
        options:
          - rolling
          - blue-green
          - canary
      force_deployment:
        description: 'Force deployment even if tests failed'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DEPLOYMENT_TIMEOUT: 600  # 10 minutes

jobs:
  # Pre-deployment validation
  pre-deployment-checks:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    if: |
      (github.event.workflow_run.conclusion == 'success' || github.event.inputs.force_deployment == 'true') ||
      github.event_name == 'workflow_dispatch'
    
    outputs:
      target-environment: ${{ steps.determine-env.outputs.environment }}
      deployment-strategy: ${{ steps.determine-strategy.outputs.strategy }}
      image-tag: ${{ steps.determine-tag.outputs.tag }}
      deploy-authorized: ${{ steps.authorization.outputs.authorized }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Determine target environment
      id: determine-env
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          ENVIRONMENT="${{ github.event.inputs.environment }}"
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          ENVIRONMENT="production"
        elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
          ENVIRONMENT="staging"
        else
          ENVIRONMENT="development"
        fi
        
        echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
        echo "üéØ Target environment: $ENVIRONMENT"

    - name: Determine deployment strategy
      id: determine-strategy
      run: |
        STRATEGY="${{ github.event.inputs.deployment_strategy || 'rolling' }}"
        ENVIRONMENT="${{ steps.determine-env.outputs.environment }}"
        
        # Force blue-green for production
        if [[ "$ENVIRONMENT" == "production" ]]; then
          STRATEGY="blue-green"
        fi
        
        echo "strategy=$STRATEGY" >> $GITHUB_OUTPUT
        echo "üöÄ Deployment strategy: $STRATEGY"

    - name: Determine image tag
      id: determine-tag
      run: |
        ENVIRONMENT="${{ steps.determine-env.outputs.environment }}"
        
        case "$ENVIRONMENT" in
          "production")
            TAG="production-latest"
            ;;
          "staging")
            TAG="staging-latest"
            ;;
          *)
            TAG="dev-latest"
            ;;
        esac
        
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "üè∑Ô∏è Image tag: $TAG"

    - name: Deployment authorization check
      id: authorization
      run: |
        ENVIRONMENT="${{ steps.determine-env.outputs.environment }}"
        AUTHORIZED="true"
        
        # Add authorization logic here (e.g., check for required approvals)
        if [[ "$ENVIRONMENT" == "production" && "${{ github.actor }}" != "admin" ]]; then
          # In real scenario, check for required reviewers/approvals
          echo "‚ö†Ô∏è Production deployment requires additional authorization"
        fi
        
        echo "authorized=$AUTHORIZED" >> $GITHUB_OUTPUT
        echo "‚úÖ Deployment authorized for $ENVIRONMENT"

  # Development environment deployment
  deploy-development:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks]
    if: needs.pre-deployment-checks.outputs.target-environment == 'development'
    environment: development

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up environment variables
      run: |
        cat > .env.development << EOF
        ENVIRONMENT=development
        BUILD_TARGET=development
        IMAGE_TAG=${{ needs.pre-deployment-checks.outputs.image-tag }}
        APP_PORT=8000
        DATABASE_URL=${{ secrets.DEV_DATABASE_URL }}
        REDIS_URL=${{ secrets.DEV_REDIS_URL }}
        MINIO_ROOT_USER=${{ secrets.DEV_MINIO_USER }}
        MINIO_ROOT_PASSWORD=${{ secrets.DEV_MINIO_PASSWORD }}
        LOG_LEVEL=DEBUG
        DEBUG=true
        EOF

    - name: Deploy to development
      run: |
        echo "üöÄ Deploying to development environment"
        
        # Pull latest images
        docker compose -f docker/docker-compose.dev.yml pull
        
        # Deploy with development configuration
        docker compose -f docker/docker-compose.dev.yml \
          --env-file .env.development \
          up -d --remove-orphans
        
        echo "‚úÖ Development deployment completed"

    - name: Health check
      run: |
        echo "üè• Performing health checks..."
        
        # Wait for services to start
        sleep 30
        
        # Check API health
        for i in {1..10}; do
          if curl -f http://localhost:8000/health; then
            echo "‚úÖ API health check passed"
            break
          fi
          echo "‚è≥ Waiting for API... ($i/10)"
          sleep 10
        done

  # Staging environment deployment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks]
    if: needs.pre-deployment-checks.outputs.target-environment == 'staging'
    environment: staging

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up environment variables
      run: |
        cat > .env.staging << EOF
        ENVIRONMENT=staging
        BUILD_TARGET=production
        IMAGE_TAG=${{ needs.pre-deployment-checks.outputs.image-tag }}
        APP_PORT=8000
        WORKERS=2
        DATABASE_URL=${{ secrets.STAGING_DATABASE_URL }}
        REDIS_URL=${{ secrets.STAGING_REDIS_URL }}
        MINIO_ROOT_USER=${{ secrets.STAGING_MINIO_USER }}
        MINIO_ROOT_PASSWORD=${{ secrets.STAGING_MINIO_PASSWORD }}
        SECRET_KEY=${{ secrets.STAGING_SECRET_KEY }}
        JWT_SECRET_KEY=${{ secrets.STAGING_JWT_SECRET }}
        LOG_LEVEL=INFO
        SENTRY_DSN=${{ secrets.STAGING_SENTRY_DSN }}
        EOF

    - name: Rolling deployment to staging
      run: |
        echo "üöÄ Starting rolling deployment to staging"
        
        # Pull latest images
        docker compose -f docker/docker-compose.prod.yml pull
        
        # Graceful rolling update
        docker compose -f docker/docker-compose.prod.yml \
          --env-file .env.staging \
          up -d --remove-orphans --no-deps app
        
        # Wait for new container to be healthy
        sleep 60
        
        echo "‚úÖ Staging deployment completed"

    - name: Smoke tests
      run: |
        echo "üß™ Running smoke tests on staging"
        
        # Basic functionality tests
        API_URL="http://staging-api.its-camera-ai.com"
        
        # Health check
        curl -f "$API_URL/health" || exit 1
        
        # API version check
        VERSION=$(curl -s "$API_URL/version" | jq -r '.version')
        echo "üì¶ Deployed version: $VERSION"
        
        # Basic API endpoints
        curl -f "$API_URL/api/v1/cameras" || exit 1
        
        echo "‚úÖ Smoke tests passed"

    - name: Integration tests
      run: |
        echo "üîó Running integration tests"
        
        # Run critical integration tests against staging
        docker run --rm \
          -e BASE_URL=http://staging-api.its-camera-ai.com \
          -e ENVIRONMENT=staging \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-checks.outputs.image-tag }} \
          pytest tests/integration/critical/ -v
        
        echo "‚úÖ Integration tests passed"

  # Production deployment with blue-green strategy
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks]
    if: needs.pre-deployment-checks.outputs.target-environment == 'production'
    environment: production

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Determine current environment
      id: current-env
      run: |
        # Check which environment is currently active
        CURRENT=$(curl -s http://prod-api.its-camera-ai.com/health | jq -r '.environment' 2>/dev/null || echo "blue")
        NEXT=$([ "$CURRENT" = "blue" ] && echo "green" || echo "blue")
        
        echo "current=$CURRENT" >> $GITHUB_OUTPUT
        echo "next=$NEXT" >> $GITHUB_OUTPUT
        
        echo "üîµ Current environment: $CURRENT"
        echo "üü¢ Deploying to: $NEXT"

    - name: Set up environment variables
      run: |
        cat > .env.production << EOF
        ENVIRONMENT=production
        BUILD_TARGET=production
        IMAGE_TAG=${{ needs.pre-deployment-checks.outputs.image-tag }}
        DEPLOYMENT_COLOR=${{ steps.current-env.outputs.next }}
        APP_PORT=8000
        WORKERS=4
        DATABASE_URL=${{ secrets.PRODUCTION_DATABASE_URL }}
        REDIS_URL=${{ secrets.PRODUCTION_REDIS_URL }}
        MINIO_ROOT_USER=${{ secrets.PRODUCTION_MINIO_USER }}
        MINIO_ROOT_PASSWORD=${{ secrets.PRODUCTION_MINIO_PASSWORD }}
        SECRET_KEY=${{ secrets.PRODUCTION_SECRET_KEY }}
        JWT_SECRET_KEY=${{ secrets.PRODUCTION_JWT_SECRET }}
        LOG_LEVEL=WARNING
        SENTRY_DSN=${{ secrets.PRODUCTION_SENTRY_DSN }}
        PROMETHEUS_METRICS=true
        EOF

    - name: Blue-Green deployment
      id: deployment
      run: |
        NEXT_ENV="${{ steps.current-env.outputs.next }}"
        
        echo "üöÄ Starting blue-green deployment to $NEXT_ENV environment"
        
        # Pull latest production images
        docker compose -f docker/docker-compose.prod.yml pull
        
        # Deploy to next environment
        docker compose -f docker/docker-compose.prod.yml \
          --env-file .env.production \
          -p its-camera-ai-$NEXT_ENV \
          up -d --remove-orphans
        
        echo "deployment-id=its-camera-ai-$NEXT_ENV" >> $GITHUB_OUTPUT
        echo "‚úÖ Deployed to $NEXT_ENV environment"

    - name: Health validation
      run: |
        NEXT_ENV="${{ steps.current-env.outputs.next }}"
        HEALTH_URL="http://prod-$NEXT_ENV-api.its-camera-ai.com/health"
        
        echo "üè• Validating health of new environment"
        
        # Extended health check with retries
        for i in {1..20}; do
          if curl -f "$HEALTH_URL" -H "Accept: application/json" --max-time 10; then
            echo "‚úÖ Health check passed on attempt $i"
            HEALTHY=true
            break
          fi
          echo "‚è≥ Health check failed, retrying... ($i/20)"
          sleep 30
        done
        
        if [[ "$HEALTHY" != "true" ]]; then
          echo "‚ùå Health checks failed after 20 attempts"
          exit 1
        fi

    - name: Load testing validation
      run: |
        NEXT_ENV="${{ steps.current-env.outputs.next }}"
        BASE_URL="http://prod-$NEXT_ENV-api.its-camera-ai.com"
        
        echo "üîÑ Running load tests on new environment"
        
        # Run load tests to validate performance
        docker run --rm \
          -e BASE_URL="$BASE_URL" \
          -e DURATION=2m \
          -e VUS=10 \
          grafana/k6:latest run - <<EOF
        import http from 'k6/http';
        import { check, sleep } from 'k6';
        
        export let options = {
          vus: parseInt(__ENV.VUS || '10'),
          duration: __ENV.DURATION || '2m',
          thresholds: {
            http_req_duration: ['p(95)<500'],
            http_req_failed: ['rate<0.05'],
          },
        };
        
        export default function() {
          let response = http.get(__ENV.BASE_URL + '/health');
          check(response, {
            'status is 200': (r) => r.status === 200,
            'response time < 500ms': (r) => r.timings.duration < 500,
          });
          sleep(1);
        }
        EOF
        
        echo "‚úÖ Load testing validation passed"

    - name: Traffic switch
      run: |
        CURRENT_ENV="${{ steps.current-env.outputs.current }}"
        NEXT_ENV="${{ steps.current-env.outputs.next }}"
        
        echo "üîÑ Switching traffic from $CURRENT_ENV to $NEXT_ENV"
        
        # In a real scenario, this would update load balancer configuration
        # For this example, we'll simulate the traffic switch
        
        # Update load balancer to point to new environment
        # (This would be specific to your infrastructure - AWS ALB, nginx, etc.)
        
        echo "‚úÖ Traffic switched to $NEXT_ENV environment"

    - name: Post-switch validation
      run: |
        echo "üîç Post-switch validation"
        
        # Validate production traffic is flowing correctly
        for i in {1..5}; do
          RESPONSE=$(curl -s http://prod-api.its-camera-ai.com/health)
          if echo "$RESPONSE" | jq -e '.status == "healthy"' > /dev/null; then
            echo "‚úÖ Production validation $i/5 passed"
          else
            echo "‚ùå Production validation $i/5 failed"
            exit 1
          fi
          sleep 10
        done

    - name: Cleanup old environment
      run: |
        CURRENT_ENV="${{ steps.current-env.outputs.current }}"
        
        echo "üßπ Cleaning up old environment: $CURRENT_ENV"
        
        # Stop and remove old environment
        docker compose -f docker/docker-compose.prod.yml \
          -p its-camera-ai-$CURRENT_ENV \
          down --remove-orphans
        
        echo "‚úÖ Cleanup completed"

    - name: Rollback on failure
      if: failure()
      run: |
        CURRENT_ENV="${{ steps.current-env.outputs.current }}"
        NEXT_ENV="${{ steps.current-env.outputs.next }}"
        DEPLOYMENT_ID="${{ steps.deployment.outputs.deployment-id }}"
        
        echo "‚ùå Deployment failed, initiating rollback"
        
        # Stop failed deployment
        if [[ -n "$DEPLOYMENT_ID" ]]; then
          docker compose -f docker/docker-compose.prod.yml \
            -p "$DEPLOYMENT_ID" \
            down --remove-orphans
        fi
        
        # Ensure current environment is running
        docker compose -f docker/docker-compose.prod.yml \
          -p its-camera-ai-$CURRENT_ENV \
          up -d --remove-orphans
        
        # Verify rollback
        sleep 30
        curl -f http://prod-api.its-camera-ai.com/health || {
          echo "‚ùå Rollback verification failed"
          exit 1
        }
        
        echo "üîÑ Rollback completed successfully"

  # Post-deployment monitoring and notifications
  post-deployment:
    name: Post-Deployment Monitoring
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, deploy-development, deploy-staging, deploy-production]
    if: always() && needs.pre-deployment-checks.result == 'success'

    steps:
    - name: Deployment summary
      run: |
        ENVIRONMENT="${{ needs.pre-deployment-checks.outputs.target-environment }}"
        
        echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| Environment | $ENVIRONMENT |" >> $GITHUB_STEP_SUMMARY
        echo "| Strategy | ${{ needs.pre-deployment-checks.outputs.deployment-strategy }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Image Tag | ${{ needs.pre-deployment-checks.outputs.image-tag }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Commit | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Branch | ${{ github.ref_name }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Add status for each environment
        DEV_STATUS="${{ needs.deploy-development.result }}"
        STAGING_STATUS="${{ needs.deploy-staging.result }}"
        PROD_STATUS="${{ needs.deploy-production.result }}"
        
        if [[ "$DEV_STATUS" != "" ]]; then
          STATUS_ICON=$([ "$DEV_STATUS" = "success" ] && echo "‚úÖ" || echo "‚ùå")
          echo "| Development | $STATUS_ICON $DEV_STATUS |" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [[ "$STAGING_STATUS" != "" ]]; then
          STATUS_ICON=$([ "$STAGING_STATUS" = "success" ] && echo "‚úÖ" || echo "‚ùå")
          echo "| Staging | $STATUS_ICON $STAGING_STATUS |" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [[ "$PROD_STATUS" != "" ]]; then
          STATUS_ICON=$([ "$PROD_STATUS" = "success" ] && echo "‚úÖ" || echo "‚ùå")
          echo "| Production | $STATUS_ICON $PROD_STATUS |" >> $GITHUB_STEP_SUMMARY
        fi

    - name: Send notifications
      run: |
        ENVIRONMENT="${{ needs.pre-deployment-checks.outputs.target-environment }}"
        
        # Determine overall deployment status
        if [[ "${{ needs.deploy-development.result }}" == "success" ]] || \
           [[ "${{ needs.deploy-staging.result }}" == "success" ]] || \
           [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
          STATUS="success"
          EMOJI="üöÄ"
          COLOR="good"
        else
          STATUS="failure"
          EMOJI="‚ùå"
          COLOR="danger"
        fi
        
        # Send Slack notification
        curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
          -H "Content-Type: application/json" \
          -d "{
            \"text\": \"$EMOJI ITS Camera AI deployment to $ENVIRONMENT\",
            \"attachments\": [{
              \"color\": \"$COLOR\",
              \"fields\": [
                {\"title\": \"Environment\", \"value\": \"$ENVIRONMENT\", \"short\": true},
                {\"title\": \"Status\", \"value\": \"$STATUS\", \"short\": true},
                {\"title\": \"Version\", \"value\": \"${{ github.sha }}\", \"short\": true},
                {\"title\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"short\": true},
                {\"title\": \"Actor\", \"value\": \"${{ github.actor }}\", \"short\": true},
                {\"title\": \"Strategy\", \"value\": \"${{ needs.pre-deployment-checks.outputs.deployment-strategy }}\", \"short\": true}
              ],
              \"actions\": [{
                \"type\": \"button\",
                \"text\": \"View Deployment\",
                \"url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
              }]
            }]
          }" || echo "Slack notification failed (webhook not configured)"
        
        echo "üì® Deployment notifications sent"